;buildInfoPackage: chisel3, version: 3.1.7, scalaVersion: 2.11.12, sbtVersion: 1.1.1, builtAtString: 2019-03-20 22:15:13.399, builtAtMillis: 1553120113399
circuit TestAccel : 
  extmodule VTASimDPI : 
    output dpi_wait : UInt<1>
    input reset : UInt<1>
    input clock : Clock
    
    defname = VTASimDPI
    
    
  extmodule VTAHostDPI : 
    output dpi : {req : {valid : UInt<1>, opcode : UInt<1>, addr : UInt<8>, value : UInt<32>, flip deq : UInt<1>}, flip resp : {valid : UInt<1>, bits : UInt<32>}}
    input reset : UInt<1>
    input clock : Clock
    
    defname = VTAHostDPI
    
    
  extmodule VTAMemDPI : 
    output dpi : {req : {flip valid : UInt<1>, flip opcode : UInt<1>, flip len : UInt<8>, flip addr : UInt<64>}, flip wr : {valid : UInt<1>, bits : UInt<64>}, rd : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<64>}}
    input reset : UInt<1>
    input clock : Clock
    
    defname = VTAMemDPI
    
    
  module VTASimShell : 
    input clock : Clock
    input reset : UInt<1>
    output host : {req : {valid : UInt<1>, opcode : UInt<1>, addr : UInt<8>, value : UInt<32>, flip deq : UInt<1>}, flip resp : {valid : UInt<1>, bits : UInt<32>}}
    output mem : {req : {flip valid : UInt<1>, flip opcode : UInt<1>, flip len : UInt<8>, flip addr : UInt<64>}, flip wr : {valid : UInt<1>, bits : UInt<64>}, rd : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<64>}}
    input sim_clock : Clock
    output sim_wait : UInt<1>
    
    inst mod_sim of VTASimDPI @[TestAccel.scala 37:23]
    mod_sim.dpi_wait is invalid
    mod_sim.reset is invalid
    mod_sim.clock is invalid
    inst mod_host of VTAHostDPI @[TestAccel.scala 38:24]
    mod_host.dpi is invalid
    mod_host.reset is invalid
    mod_host.clock is invalid
    inst mod_mem of VTAMemDPI @[TestAccel.scala 39:23]
    mod_mem.dpi is invalid
    mod_mem.reset is invalid
    mod_mem.clock is invalid
    mod_mem.clock <= clock @[TestAccel.scala 40:20]
    mod_mem.reset <= reset @[TestAccel.scala 41:20]
    mem.rd.bits <= mod_mem.dpi.rd.bits @[TestAccel.scala 42:18]
    mem.rd.valid <= mod_mem.dpi.rd.valid @[TestAccel.scala 42:18]
    mod_mem.dpi.rd.ready <= mem.rd.ready @[TestAccel.scala 42:18]
    mod_mem.dpi.wr.bits <= mem.wr.bits @[TestAccel.scala 42:18]
    mod_mem.dpi.wr.valid <= mem.wr.valid @[TestAccel.scala 42:18]
    mod_mem.dpi.req.addr <= mem.req.addr @[TestAccel.scala 42:18]
    mod_mem.dpi.req.len <= mem.req.len @[TestAccel.scala 42:18]
    mod_mem.dpi.req.opcode <= mem.req.opcode @[TestAccel.scala 42:18]
    mod_mem.dpi.req.valid <= mem.req.valid @[TestAccel.scala 42:18]
    mod_host.clock <= clock @[TestAccel.scala 43:21]
    mod_host.reset <= reset @[TestAccel.scala 44:21]
    mod_host.dpi.resp.bits <= host.resp.bits @[TestAccel.scala 45:8]
    mod_host.dpi.resp.valid <= host.resp.valid @[TestAccel.scala 45:8]
    mod_host.dpi.req.deq <= host.req.deq @[TestAccel.scala 45:8]
    host.req.value <= mod_host.dpi.req.value @[TestAccel.scala 45:8]
    host.req.addr <= mod_host.dpi.req.addr @[TestAccel.scala 45:8]
    host.req.opcode <= mod_host.dpi.req.opcode @[TestAccel.scala 45:8]
    host.req.valid <= mod_host.dpi.req.valid @[TestAccel.scala 45:8]
    mod_sim.clock <= sim_clock @[TestAccel.scala 46:20]
    mod_sim.reset <= reset @[TestAccel.scala 47:20]
    sim_wait <= mod_sim.dpi_wait @[TestAccel.scala 48:12]
    
  module RegFile : 
    input clock : Clock
    input reset : UInt<1>
    output io : {launch : UInt<1>, flip finish : UInt<1>, flip ecnt : {valid : UInt<1>, bits : UInt<32>}[1], vals : UInt<32>[4], ptrs : UInt<64>[3], host : {req : {flip valid : UInt<1>, flip opcode : UInt<1>, flip addr : UInt<8>, flip value : UInt<32>, deq : UInt<1>}, resp : {valid : UInt<1>, bits : UInt<32>}}}
    
    reg state : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[RegFile.scala 64:22]
    node _T_74 = eq(UInt<1>("h00"), state) @[Conditional.scala 37:30]
    when _T_74 : @[Conditional.scala 40:58]
      node _T_76 = eq(io.host.req.opcode, UInt<1>("h00")) @[RegFile.scala 68:34]
      node _T_77 = and(io.host.req.valid, _T_76) @[RegFile.scala 68:31]
      when _T_77 : @[RegFile.scala 68:55]
        state <= UInt<1>("h01") @[RegFile.scala 69:15]
        skip @[RegFile.scala 68:55]
      skip @[Conditional.scala 40:58]
    else : @[Conditional.scala 39:67]
      node _T_78 = eq(UInt<1>("h01"), state) @[Conditional.scala 37:30]
      when _T_78 : @[Conditional.scala 39:67]
        state <= UInt<1>("h00") @[RegFile.scala 73:13]
        skip @[Conditional.scala 39:67]
    node _T_79 = eq(state, UInt<1>("h00")) @[RegFile.scala 77:28]
    node _T_80 = and(_T_79, io.host.req.valid) @[RegFile.scala 77:38]
    io.host.req.deq <= _T_80 @[RegFile.scala 77:19]
    wire _T_84 : UInt<32> @[RegFile.scala 80:50]
    _T_84 <= UInt<1>("h00") @[RegFile.scala 80:50]
    reg reg_0 : UInt, clock with : (reset => (reset, _T_84)) @[RegFile.scala 80:37]
    wire _T_89 : UInt<32> @[RegFile.scala 80:50]
    _T_89 <= UInt<1>("h00") @[RegFile.scala 80:50]
    reg reg_1 : UInt, clock with : (reset => (reset, _T_89)) @[RegFile.scala 80:37]
    wire _T_94 : UInt<32> @[RegFile.scala 80:50]
    _T_94 <= UInt<1>("h00") @[RegFile.scala 80:50]
    reg reg_2 : UInt, clock with : (reset => (reset, _T_94)) @[RegFile.scala 80:37]
    wire _T_99 : UInt<32> @[RegFile.scala 80:50]
    _T_99 <= UInt<1>("h00") @[RegFile.scala 80:50]
    reg reg_3 : UInt, clock with : (reset => (reset, _T_99)) @[RegFile.scala 80:37]
    wire _T_104 : UInt<32> @[RegFile.scala 80:50]
    _T_104 <= UInt<1>("h00") @[RegFile.scala 80:50]
    reg reg_4 : UInt, clock with : (reset => (reset, _T_104)) @[RegFile.scala 80:37]
    wire _T_109 : UInt<32> @[RegFile.scala 80:50]
    _T_109 <= UInt<1>("h00") @[RegFile.scala 80:50]
    reg reg_5 : UInt, clock with : (reset => (reset, _T_109)) @[RegFile.scala 80:37]
    wire _T_114 : UInt<32> @[RegFile.scala 80:50]
    _T_114 <= UInt<1>("h00") @[RegFile.scala 80:50]
    reg reg_6 : UInt, clock with : (reset => (reset, _T_114)) @[RegFile.scala 80:37]
    wire _T_119 : UInt<32> @[RegFile.scala 80:50]
    _T_119 <= UInt<1>("h00") @[RegFile.scala 80:50]
    reg reg_7 : UInt, clock with : (reset => (reset, _T_119)) @[RegFile.scala 80:37]
    wire _T_124 : UInt<32> @[RegFile.scala 80:50]
    _T_124 <= UInt<1>("h00") @[RegFile.scala 80:50]
    reg reg_8 : UInt, clock with : (reset => (reset, _T_124)) @[RegFile.scala 80:37]
    wire _T_129 : UInt<32> @[RegFile.scala 80:50]
    _T_129 <= UInt<1>("h00") @[RegFile.scala 80:50]
    reg reg_9 : UInt, clock with : (reset => (reset, _T_129)) @[RegFile.scala 80:37]
    wire _T_134 : UInt<32> @[RegFile.scala 80:50]
    _T_134 <= UInt<1>("h00") @[RegFile.scala 80:50]
    reg reg_10 : UInt, clock with : (reset => (reset, _T_134)) @[RegFile.scala 80:37]
    wire _T_139 : UInt<32> @[RegFile.scala 80:50]
    _T_139 <= UInt<1>("h00") @[RegFile.scala 80:50]
    reg reg_11 : UInt, clock with : (reset => (reset, _T_139)) @[RegFile.scala 80:37]
    when io.finish : @[RegFile.scala 87:20]
      reg_0 <= UInt<2>("h02") @[RegFile.scala 88:12]
      skip @[RegFile.scala 87:20]
    else : @[RegFile.scala 90:63]
      node _T_154 = eq(state, UInt<1>("h00")) @[RegFile.scala 89:22]
      node _T_155 = and(_T_154, io.host.req.valid) @[RegFile.scala 89:32]
      node _T_156 = and(_T_155, io.host.req.opcode) @[RegFile.scala 89:53]
      node _T_158 = eq(UInt<1>("h00"), io.host.req.addr) @[RegFile.scala 90:41]
      node _T_159 = and(_T_156, _T_158) @[RegFile.scala 90:28]
      when _T_159 : @[RegFile.scala 90:63]
        reg_0 <= io.host.req.value @[RegFile.scala 91:12]
        skip @[RegFile.scala 90:63]
    when io.ecnt[0].valid : @[RegFile.scala 95:29]
      reg_1 <= io.ecnt[0].bits @[RegFile.scala 96:19]
      skip @[RegFile.scala 95:29]
    else : @[RegFile.scala 98:70]
      node _T_160 = eq(state, UInt<1>("h00")) @[RegFile.scala 97:24]
      node _T_161 = and(_T_160, io.host.req.valid) @[RegFile.scala 97:34]
      node _T_162 = and(_T_161, io.host.req.opcode) @[RegFile.scala 97:55]
      node _T_164 = eq(UInt<3>("h04"), io.host.req.addr) @[RegFile.scala 98:48]
      node _T_165 = and(_T_162, _T_164) @[RegFile.scala 98:30]
      when _T_165 : @[RegFile.scala 98:70]
        reg_1 <= io.host.req.value @[RegFile.scala 99:19]
        skip @[RegFile.scala 98:70]
    node _T_166 = eq(state, UInt<1>("h00")) @[RegFile.scala 104:17]
    node _T_167 = and(_T_166, io.host.req.valid) @[RegFile.scala 104:27]
    node _T_168 = and(_T_167, io.host.req.opcode) @[RegFile.scala 104:48]
    node _T_170 = eq(UInt<4>("h08"), io.host.req.addr) @[RegFile.scala 105:48]
    node _T_171 = and(_T_168, _T_170) @[RegFile.scala 105:30]
    when _T_171 : @[RegFile.scala 105:70]
      reg_2 <= io.host.req.value @[RegFile.scala 106:19]
      skip @[RegFile.scala 105:70]
    node _T_172 = eq(state, UInt<1>("h00")) @[RegFile.scala 104:17]
    node _T_173 = and(_T_172, io.host.req.valid) @[RegFile.scala 104:27]
    node _T_174 = and(_T_173, io.host.req.opcode) @[RegFile.scala 104:48]
    node _T_176 = eq(UInt<4>("h0c"), io.host.req.addr) @[RegFile.scala 105:48]
    node _T_177 = and(_T_174, _T_176) @[RegFile.scala 105:30]
    when _T_177 : @[RegFile.scala 105:70]
      reg_3 <= io.host.req.value @[RegFile.scala 106:19]
      skip @[RegFile.scala 105:70]
    node _T_178 = eq(state, UInt<1>("h00")) @[RegFile.scala 104:17]
    node _T_179 = and(_T_178, io.host.req.valid) @[RegFile.scala 104:27]
    node _T_180 = and(_T_179, io.host.req.opcode) @[RegFile.scala 104:48]
    node _T_182 = eq(UInt<5>("h010"), io.host.req.addr) @[RegFile.scala 105:48]
    node _T_183 = and(_T_180, _T_182) @[RegFile.scala 105:30]
    when _T_183 : @[RegFile.scala 105:70]
      reg_4 <= io.host.req.value @[RegFile.scala 106:19]
      skip @[RegFile.scala 105:70]
    node _T_184 = eq(state, UInt<1>("h00")) @[RegFile.scala 104:17]
    node _T_185 = and(_T_184, io.host.req.valid) @[RegFile.scala 104:27]
    node _T_186 = and(_T_185, io.host.req.opcode) @[RegFile.scala 104:48]
    node _T_188 = eq(UInt<5>("h014"), io.host.req.addr) @[RegFile.scala 105:48]
    node _T_189 = and(_T_186, _T_188) @[RegFile.scala 105:30]
    when _T_189 : @[RegFile.scala 105:70]
      reg_5 <= io.host.req.value @[RegFile.scala 106:19]
      skip @[RegFile.scala 105:70]
    node _T_190 = eq(state, UInt<1>("h00")) @[RegFile.scala 104:17]
    node _T_191 = and(_T_190, io.host.req.valid) @[RegFile.scala 104:27]
    node _T_192 = and(_T_191, io.host.req.opcode) @[RegFile.scala 104:48]
    node _T_194 = eq(UInt<5>("h018"), io.host.req.addr) @[RegFile.scala 105:48]
    node _T_195 = and(_T_192, _T_194) @[RegFile.scala 105:30]
    when _T_195 : @[RegFile.scala 105:70]
      reg_6 <= io.host.req.value @[RegFile.scala 106:19]
      skip @[RegFile.scala 105:70]
    node _T_196 = eq(state, UInt<1>("h00")) @[RegFile.scala 104:17]
    node _T_197 = and(_T_196, io.host.req.valid) @[RegFile.scala 104:27]
    node _T_198 = and(_T_197, io.host.req.opcode) @[RegFile.scala 104:48]
    node _T_200 = eq(UInt<5>("h01c"), io.host.req.addr) @[RegFile.scala 105:48]
    node _T_201 = and(_T_198, _T_200) @[RegFile.scala 105:30]
    when _T_201 : @[RegFile.scala 105:70]
      reg_7 <= io.host.req.value @[RegFile.scala 106:19]
      skip @[RegFile.scala 105:70]
    node _T_202 = eq(state, UInt<1>("h00")) @[RegFile.scala 104:17]
    node _T_203 = and(_T_202, io.host.req.valid) @[RegFile.scala 104:27]
    node _T_204 = and(_T_203, io.host.req.opcode) @[RegFile.scala 104:48]
    node _T_206 = eq(UInt<6>("h020"), io.host.req.addr) @[RegFile.scala 105:48]
    node _T_207 = and(_T_204, _T_206) @[RegFile.scala 105:30]
    when _T_207 : @[RegFile.scala 105:70]
      reg_8 <= io.host.req.value @[RegFile.scala 106:19]
      skip @[RegFile.scala 105:70]
    node _T_208 = eq(state, UInt<1>("h00")) @[RegFile.scala 104:17]
    node _T_209 = and(_T_208, io.host.req.valid) @[RegFile.scala 104:27]
    node _T_210 = and(_T_209, io.host.req.opcode) @[RegFile.scala 104:48]
    node _T_212 = eq(UInt<6>("h024"), io.host.req.addr) @[RegFile.scala 105:48]
    node _T_213 = and(_T_210, _T_212) @[RegFile.scala 105:30]
    when _T_213 : @[RegFile.scala 105:70]
      reg_9 <= io.host.req.value @[RegFile.scala 106:19]
      skip @[RegFile.scala 105:70]
    node _T_214 = eq(state, UInt<1>("h00")) @[RegFile.scala 104:17]
    node _T_215 = and(_T_214, io.host.req.valid) @[RegFile.scala 104:27]
    node _T_216 = and(_T_215, io.host.req.opcode) @[RegFile.scala 104:48]
    node _T_218 = eq(UInt<6>("h028"), io.host.req.addr) @[RegFile.scala 105:48]
    node _T_219 = and(_T_216, _T_218) @[RegFile.scala 105:30]
    when _T_219 : @[RegFile.scala 105:70]
      reg_10 <= io.host.req.value @[RegFile.scala 106:19]
      skip @[RegFile.scala 105:70]
    node _T_220 = eq(state, UInt<1>("h00")) @[RegFile.scala 104:17]
    node _T_221 = and(_T_220, io.host.req.valid) @[RegFile.scala 104:27]
    node _T_222 = and(_T_221, io.host.req.opcode) @[RegFile.scala 104:48]
    node _T_224 = eq(UInt<6>("h02c"), io.host.req.addr) @[RegFile.scala 105:48]
    node _T_225 = and(_T_222, _T_224) @[RegFile.scala 105:30]
    when _T_225 : @[RegFile.scala 105:70]
      reg_11 <= io.host.req.value @[RegFile.scala 106:19]
      skip @[RegFile.scala 105:70]
    wire _T_229 : UInt<32> @[RegFile.scala 110:35]
    _T_229 <= UInt<1>("h00") @[RegFile.scala 110:35]
    reg rdata : UInt, clock with : (reset => (reset, _T_229)) @[RegFile.scala 110:22]
    node _T_231 = eq(state, UInt<1>("h00")) @[RegFile.scala 111:15]
    node _T_232 = and(_T_231, io.host.req.valid) @[RegFile.scala 111:25]
    node _T_234 = eq(io.host.req.opcode, UInt<1>("h00")) @[RegFile.scala 111:49]
    node _T_235 = and(_T_232, _T_234) @[RegFile.scala 111:46]
    when _T_235 : @[RegFile.scala 111:70]
      node _T_237 = eq(UInt<6>("h02c"), io.host.req.addr) @[Mux.scala 46:19]
      node _T_238 = mux(_T_237, reg_11, UInt<1>("h00")) @[Mux.scala 46:16]
      node _T_239 = eq(UInt<6>("h028"), io.host.req.addr) @[Mux.scala 46:19]
      node _T_240 = mux(_T_239, reg_10, _T_238) @[Mux.scala 46:16]
      node _T_241 = eq(UInt<6>("h024"), io.host.req.addr) @[Mux.scala 46:19]
      node _T_242 = mux(_T_241, reg_9, _T_240) @[Mux.scala 46:16]
      node _T_243 = eq(UInt<6>("h020"), io.host.req.addr) @[Mux.scala 46:19]
      node _T_244 = mux(_T_243, reg_8, _T_242) @[Mux.scala 46:16]
      node _T_245 = eq(UInt<5>("h01c"), io.host.req.addr) @[Mux.scala 46:19]
      node _T_246 = mux(_T_245, reg_7, _T_244) @[Mux.scala 46:16]
      node _T_247 = eq(UInt<5>("h018"), io.host.req.addr) @[Mux.scala 46:19]
      node _T_248 = mux(_T_247, reg_6, _T_246) @[Mux.scala 46:16]
      node _T_249 = eq(UInt<5>("h014"), io.host.req.addr) @[Mux.scala 46:19]
      node _T_250 = mux(_T_249, reg_5, _T_248) @[Mux.scala 46:16]
      node _T_251 = eq(UInt<5>("h010"), io.host.req.addr) @[Mux.scala 46:19]
      node _T_252 = mux(_T_251, reg_4, _T_250) @[Mux.scala 46:16]
      node _T_253 = eq(UInt<4>("h0c"), io.host.req.addr) @[Mux.scala 46:19]
      node _T_254 = mux(_T_253, reg_3, _T_252) @[Mux.scala 46:16]
      node _T_255 = eq(UInt<4>("h08"), io.host.req.addr) @[Mux.scala 46:19]
      node _T_256 = mux(_T_255, reg_2, _T_254) @[Mux.scala 46:16]
      node _T_257 = eq(UInt<3>("h04"), io.host.req.addr) @[Mux.scala 46:19]
      node _T_258 = mux(_T_257, reg_1, _T_256) @[Mux.scala 46:16]
      node _T_259 = eq(UInt<1>("h00"), io.host.req.addr) @[Mux.scala 46:19]
      node _T_260 = mux(_T_259, reg_0, _T_258) @[Mux.scala 46:16]
      rdata <= _T_260 @[RegFile.scala 112:11]
      skip @[RegFile.scala 111:70]
    node _T_261 = eq(state, UInt<1>("h01")) @[RegFile.scala 115:31]
    io.host.resp.valid <= _T_261 @[RegFile.scala 115:22]
    io.host.resp.bits <= rdata @[RegFile.scala 116:21]
    node _T_262 = bits(reg_0, 0, 0) @[RegFile.scala 118:22]
    io.launch <= _T_262 @[RegFile.scala 118:13]
    io.vals[0] <= reg_2 @[RegFile.scala 121:16]
    io.vals[1] <= reg_3 @[RegFile.scala 121:16]
    io.vals[2] <= reg_4 @[RegFile.scala 121:16]
    io.vals[3] <= reg_5 @[RegFile.scala 121:16]
    node _T_263 = cat(reg_7, reg_6) @[Cat.scala 30:58]
    io.ptrs[0] <= _T_263 @[RegFile.scala 125:16]
    node _T_264 = cat(reg_9, reg_8) @[Cat.scala 30:58]
    io.ptrs[1] <= _T_264 @[RegFile.scala 125:16]
    node _T_265 = cat(reg_11, reg_10) @[Cat.scala 30:58]
    io.ptrs[2] <= _T_265 @[RegFile.scala 125:16]
    
  module Dot : 
    input clock : Clock
    input reset : UInt<1>
    output io : {flip start : UInt<1>, flip arrA : UInt<8>[8], flip arrB : UInt<8>[8], valid : UInt<1>, res : UInt<23>}
    
    wire _T_74 : UInt<16>[8] @[Compute.scala 188:28]
    _T_74[0] <= UInt<16>("h00") @[Compute.scala 188:28]
    _T_74[1] <= UInt<16>("h00") @[Compute.scala 188:28]
    _T_74[2] <= UInt<16>("h00") @[Compute.scala 188:28]
    _T_74[3] <= UInt<16>("h00") @[Compute.scala 188:28]
    _T_74[4] <= UInt<16>("h00") @[Compute.scala 188:28]
    _T_74[5] <= UInt<16>("h00") @[Compute.scala 188:28]
    _T_74[6] <= UInt<16>("h00") @[Compute.scala 188:28]
    _T_74[7] <= UInt<16>("h00") @[Compute.scala 188:28]
    reg product : UInt<16>[8], clock with : (reset => (reset, _T_74)) @[Compute.scala 188:24]
    wire _T_144 : UInt<23>[8] @[Compute.scala 189:26]
    _T_144[0] <= UInt<23>("h00") @[Compute.scala 189:26]
    _T_144[1] <= UInt<23>("h00") @[Compute.scala 189:26]
    _T_144[2] <= UInt<23>("h00") @[Compute.scala 189:26]
    _T_144[3] <= UInt<23>("h00") @[Compute.scala 189:26]
    _T_144[4] <= UInt<23>("h00") @[Compute.scala 189:26]
    _T_144[5] <= UInt<23>("h00") @[Compute.scala 189:26]
    _T_144[6] <= UInt<23>("h00") @[Compute.scala 189:26]
    _T_144[7] <= UInt<23>("h00") @[Compute.scala 189:26]
    reg accum : UInt<23>[8], clock with : (reset => (reset, _T_144)) @[Compute.scala 189:22]
    reg cnt : UInt<4>, clock with : (reset => (reset, UInt<4>("h00"))) @[Compute.scala 190:20]
    when io.start : @[Compute.scala 191:19]
      cnt <= UInt<1>("h00") @[Compute.scala 192:9]
      skip @[Compute.scala 191:19]
    else : @[Compute.scala 193:16]
      accum[0] <= product[0] @[Compute.scala 194:14]
      node _T_206 = mul(io.arrA[0], io.arrB[0]) @[Compute.scala 195:30]
      product[0] <= _T_206 @[Compute.scala 195:16]
      node _T_207 = mul(io.arrA[1], io.arrB[1]) @[Compute.scala 197:32]
      product[1] <= _T_207 @[Compute.scala 197:18]
      node _T_208 = add(accum[0], product[1]) @[Compute.scala 198:30]
      accum[1] <= _T_208 @[Compute.scala 198:16]
      node _T_209 = mul(io.arrA[2], io.arrB[2]) @[Compute.scala 197:32]
      product[2] <= _T_209 @[Compute.scala 197:18]
      node _T_210 = add(accum[1], product[2]) @[Compute.scala 198:30]
      accum[2] <= _T_210 @[Compute.scala 198:16]
      node _T_211 = mul(io.arrA[3], io.arrB[3]) @[Compute.scala 197:32]
      product[3] <= _T_211 @[Compute.scala 197:18]
      node _T_212 = add(accum[2], product[3]) @[Compute.scala 198:30]
      accum[3] <= _T_212 @[Compute.scala 198:16]
      node _T_213 = mul(io.arrA[4], io.arrB[4]) @[Compute.scala 197:32]
      product[4] <= _T_213 @[Compute.scala 197:18]
      node _T_214 = add(accum[3], product[4]) @[Compute.scala 198:30]
      accum[4] <= _T_214 @[Compute.scala 198:16]
      node _T_215 = mul(io.arrA[5], io.arrB[5]) @[Compute.scala 197:32]
      product[5] <= _T_215 @[Compute.scala 197:18]
      node _T_216 = add(accum[4], product[5]) @[Compute.scala 198:30]
      accum[5] <= _T_216 @[Compute.scala 198:16]
      node _T_217 = mul(io.arrA[6], io.arrB[6]) @[Compute.scala 197:32]
      product[6] <= _T_217 @[Compute.scala 197:18]
      node _T_218 = add(accum[5], product[6]) @[Compute.scala 198:30]
      accum[6] <= _T_218 @[Compute.scala 198:16]
      node _T_219 = mul(io.arrA[7], io.arrB[7]) @[Compute.scala 197:32]
      product[7] <= _T_219 @[Compute.scala 197:18]
      node _T_220 = add(accum[6], product[7]) @[Compute.scala 198:30]
      accum[7] <= _T_220 @[Compute.scala 198:16]
      node _T_222 = add(cnt, UInt<1>("h01")) @[Compute.scala 202:16]
      node _T_223 = tail(_T_222, 1) @[Compute.scala 202:16]
      cnt <= _T_223 @[Compute.scala 202:9]
      skip @[Compute.scala 193:16]
    io.res <= accum[7] @[Compute.scala 206:10]
    node _T_225 = eq(cnt, UInt<4>("h08")) @[Compute.scala 207:19]
    io.valid <= _T_225 @[Compute.scala 207:12]
    
  module Accumulator : 
    input clock : Clock
    input reset : UInt<1>
    output io : {flip rst : UInt<1>, flip valid : UInt<1>, ready : UInt<1>, flip in : UInt<63>, sum : UInt<64>}
    
    reg reg : UInt<64>, clock with : (reset => (reset, UInt<64>("h00"))) @[Compute.scala 219:20]
    reg ready : UInt<1>, clock @[Compute.scala 220:22]
    ready <= io.valid @[Compute.scala 220:22]
    when io.rst : @[Compute.scala 221:17]
      reg <= UInt<1>("h00") @[Compute.scala 222:9]
      skip @[Compute.scala 221:17]
    else : @[Compute.scala 223:26]
      when io.valid : @[Compute.scala 223:26]
        node _T_19 = add(reg, io.in) @[Compute.scala 224:16]
        reg <= _T_19 @[Compute.scala 224:9]
        node _T_20 = add(reg, io.in) @[Compute.scala 225:36]
        node _T_21 = bits(reset, 0, 0) @[Compute.scala 225:11]
        node _T_23 = eq(_T_21, UInt<1>("h00")) @[Compute.scala 225:11]
        when _T_23 : @[Compute.scala 225:11]
          printf(clock, UInt<1>(1), "slice sum: %d \n", _T_20) @[Compute.scala 225:11]
          skip @[Compute.scala 225:11]
        skip @[Compute.scala 223:26]
    io.ready <= ready @[Compute.scala 231:12]
    io.sum <= reg @[Compute.scala 232:10]
    
  module Compute : 
    input clock : Clock
    input reset : UInt<1>
    output io : {flip launch : UInt<1>, finish : UInt<1>, ecnt : {valid : UInt<1>, bits : UInt<32>}[1], flip vals : UInt<32>[4], flip ptrs : UInt<64>[3], mem : {req : {valid : UInt<1>, opcode : UInt<1>, len : UInt<8>, addr : UInt<64>}, wr : {valid : UInt<1>, bits : UInt<64>}, flip rd : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<64>}}}
    
    reg state : UInt<3>, clock with : (reset => (reset, UInt<3>("h00"))) @[Compute.scala 48:22]
    node shift = bits(io.vals[0], 7, 0) @[Compute.scala 49:25]
    reg cycles : UInt<32>, clock with : (reset => (reset, UInt<32>("h00"))) @[Compute.scala 53:23]
    reg reg1 : UInt<32>[8], clock @[Compute.scala 54:17]
    reg reg2 : UInt<32>[8], clock @[Compute.scala 55:17]
    reg cnt : UInt<32>, clock @[Compute.scala 56:16]
    reg raddr1 : UInt<64>, clock @[Compute.scala 57:19]
    reg raddr2 : UInt<64>, clock @[Compute.scala 58:19]
    reg waddr : UInt<64>, clock @[Compute.scala 59:18]
    node _T_112 = eq(UInt<3>("h00"), state) @[Conditional.scala 37:30]
    when _T_112 : @[Conditional.scala 40:58]
      when io.launch : @[Compute.scala 69:24]
        state <= UInt<3>("h01") @[Compute.scala 70:15]
        skip @[Compute.scala 69:24]
      skip @[Conditional.scala 40:58]
    else : @[Conditional.scala 39:67]
      node _T_113 = eq(UInt<3>("h01"), state) @[Conditional.scala 37:30]
      when _T_113 : @[Conditional.scala 39:67]
        state <= UInt<3>("h02") @[Compute.scala 75:13]
        skip @[Conditional.scala 39:67]
      else : @[Conditional.scala 39:67]
        node _T_114 = eq(UInt<3>("h02"), state) @[Conditional.scala 37:30]
        when _T_114 : @[Conditional.scala 39:67]
          when io.mem.rd.valid : @[Compute.scala 78:30]
            state <= UInt<3>("h03") @[Compute.scala 79:15]
            skip @[Compute.scala 78:30]
          skip @[Conditional.scala 39:67]
        else : @[Conditional.scala 39:67]
          node _T_115 = eq(UInt<3>("h03"), state) @[Conditional.scala 37:30]
          when _T_115 : @[Conditional.scala 39:67]
            state <= UInt<3>("h04") @[Compute.scala 83:13]
            skip @[Conditional.scala 39:67]
          else : @[Conditional.scala 39:67]
            node _T_116 = eq(UInt<3>("h04"), state) @[Conditional.scala 37:30]
            when _T_116 : @[Conditional.scala 39:67]
              when io.mem.rd.valid : @[Compute.scala 86:30]
                state <= UInt<3>("h05") @[Compute.scala 87:15]
                skip @[Compute.scala 86:30]
              skip @[Conditional.scala 39:67]
            else : @[Conditional.scala 39:67]
              node _T_117 = eq(UInt<3>("h05"), state) @[Conditional.scala 37:30]
              when _T_117 : @[Conditional.scala 39:67]
                state <= UInt<3>("h06") @[Compute.scala 92:13]
                skip @[Conditional.scala 39:67]
              else : @[Conditional.scala 39:67]
                node _T_118 = eq(UInt<3>("h06"), state) @[Conditional.scala 37:30]
                when _T_118 : @[Conditional.scala 39:67]
                  node _T_120 = sub(io.vals[1], UInt<1>("h01")) @[Compute.scala 95:29]
                  node _T_121 = asUInt(_T_120) @[Compute.scala 95:29]
                  node _T_122 = tail(_T_121, 1) @[Compute.scala 95:29]
                  node _T_123 = eq(cnt, _T_122) @[Compute.scala 95:17]
                  when _T_123 : @[Compute.scala 95:37]
                    state <= UInt<3>("h00") @[Compute.scala 96:15]
                    skip @[Compute.scala 95:37]
                  else : @[Compute.scala 97:20]
                    state <= UInt<3>("h01") @[Compute.scala 98:15]
                    skip @[Compute.scala 97:20]
                  skip @[Conditional.scala 39:67]
    node _T_124 = eq(state, UInt<3>("h06")) @[Compute.scala 103:20]
    node _T_126 = sub(io.vals[1], UInt<1>("h01")) @[Compute.scala 103:54]
    node _T_127 = asUInt(_T_126) @[Compute.scala 103:54]
    node _T_128 = tail(_T_127, 1) @[Compute.scala 103:54]
    node _T_129 = eq(cnt, _T_128) @[Compute.scala 103:42]
    node last = and(_T_124, _T_129) @[Compute.scala 103:35]
    node _T_130 = eq(state, UInt<3>("h00")) @[Compute.scala 106:15]
    when _T_130 : @[Compute.scala 106:26]
      cycles <= UInt<1>("h00") @[Compute.scala 107:12]
      skip @[Compute.scala 106:26]
    else : @[Compute.scala 108:16]
      node _T_133 = add(cycles, UInt<1>("h01")) @[Compute.scala 109:22]
      node _T_134 = tail(_T_133, 1) @[Compute.scala 109:22]
      cycles <= _T_134 @[Compute.scala 109:12]
      skip @[Compute.scala 108:16]
    io.ecnt[0].valid <= last @[Compute.scala 112:20]
    io.ecnt[0].bits <= cycles @[Compute.scala 113:19]
    node _T_135 = eq(state, UInt<3>("h00")) @[Compute.scala 116:15]
    when _T_135 : @[Compute.scala 116:26]
      raddr1 <= io.ptrs[0] @[Compute.scala 117:12]
      raddr2 <= io.ptrs[1] @[Compute.scala 118:12]
      waddr <= io.ptrs[2] @[Compute.scala 119:11]
      skip @[Compute.scala 116:26]
    else : @[Compute.scala 120:38]
      node _T_136 = eq(state, UInt<3>("h06")) @[Compute.scala 120:22]
      when _T_136 : @[Compute.scala 120:38]
        node _T_138 = add(raddr1, UInt<4>("h08")) @[Compute.scala 121:22]
        node _T_139 = tail(_T_138, 1) @[Compute.scala 121:22]
        raddr1 <= _T_139 @[Compute.scala 121:12]
        node _T_141 = add(raddr2, UInt<4>("h08")) @[Compute.scala 122:22]
        node _T_142 = tail(_T_141, 1) @[Compute.scala 122:22]
        raddr2 <= _T_142 @[Compute.scala 122:12]
        skip @[Compute.scala 120:38]
    node _T_143 = eq(state, UInt<3>("h01")) @[Compute.scala 127:29]
    node _T_144 = eq(state, UInt<3>("h03")) @[Compute.scala 127:51]
    node _T_145 = or(_T_143, _T_144) @[Compute.scala 127:43]
    node _T_146 = eq(state, UInt<3>("h05")) @[Compute.scala 127:73]
    node _T_147 = or(_T_145, _T_146) @[Compute.scala 127:65]
    io.mem.req.valid <= _T_147 @[Compute.scala 127:20]
    node _T_148 = eq(state, UInt<3>("h05")) @[Compute.scala 128:30]
    io.mem.req.opcode <= _T_148 @[Compute.scala 128:21]
    io.mem.req.len <= UInt<1>("h00") @[Compute.scala 129:18]
    node _T_150 = eq(state, UInt<3>("h01")) @[Compute.scala 130:32]
    node _T_151 = eq(state, UInt<3>("h03")) @[Compute.scala 130:54]
    node _T_152 = or(_T_150, _T_151) @[Compute.scala 130:46]
    node _T_153 = eq(state, UInt<3>("h01")) @[Compute.scala 130:79]
    node _T_154 = mux(_T_153, raddr1, raddr2) @[Compute.scala 130:72]
    node _T_155 = mux(_T_152, _T_154, waddr) @[Compute.scala 130:25]
    io.mem.req.addr <= _T_155 @[Compute.scala 130:19]
    node _T_156 = eq(state, UInt<3>("h02")) @[Compute.scala 133:15]
    node _T_157 = and(_T_156, io.mem.rd.valid) @[Compute.scala 133:30]
    when _T_157 : @[Compute.scala 133:50]
      node _T_158 = bits(io.mem.rd.bits, 7, 0) @[Compute.scala 135:32]
      reg1[0] <= _T_158 @[Compute.scala 135:15]
      node _T_159 = bits(io.mem.rd.bits, 7, 0) @[Compute.scala 136:52]
      node _T_160 = bits(reset, 0, 0) @[Compute.scala 136:13]
      node _T_162 = eq(_T_160, UInt<1>("h00")) @[Compute.scala 136:13]
      when _T_162 : @[Compute.scala 136:13]
        printf(clock, UInt<1>(1), "slice inputs1: %d \n", _T_159) @[Compute.scala 136:13]
        skip @[Compute.scala 136:13]
      node _T_163 = bits(io.mem.rd.bits, 15, 8) @[Compute.scala 135:32]
      reg1[1] <= _T_163 @[Compute.scala 135:15]
      node _T_164 = bits(io.mem.rd.bits, 15, 8) @[Compute.scala 136:52]
      node _T_165 = bits(reset, 0, 0) @[Compute.scala 136:13]
      node _T_167 = eq(_T_165, UInt<1>("h00")) @[Compute.scala 136:13]
      when _T_167 : @[Compute.scala 136:13]
        printf(clock, UInt<1>(1), "slice inputs1: %d \n", _T_164) @[Compute.scala 136:13]
        skip @[Compute.scala 136:13]
      node _T_168 = bits(io.mem.rd.bits, 23, 16) @[Compute.scala 135:32]
      reg1[2] <= _T_168 @[Compute.scala 135:15]
      node _T_169 = bits(io.mem.rd.bits, 23, 16) @[Compute.scala 136:52]
      node _T_170 = bits(reset, 0, 0) @[Compute.scala 136:13]
      node _T_172 = eq(_T_170, UInt<1>("h00")) @[Compute.scala 136:13]
      when _T_172 : @[Compute.scala 136:13]
        printf(clock, UInt<1>(1), "slice inputs1: %d \n", _T_169) @[Compute.scala 136:13]
        skip @[Compute.scala 136:13]
      node _T_173 = bits(io.mem.rd.bits, 31, 24) @[Compute.scala 135:32]
      reg1[3] <= _T_173 @[Compute.scala 135:15]
      node _T_174 = bits(io.mem.rd.bits, 31, 24) @[Compute.scala 136:52]
      node _T_175 = bits(reset, 0, 0) @[Compute.scala 136:13]
      node _T_177 = eq(_T_175, UInt<1>("h00")) @[Compute.scala 136:13]
      when _T_177 : @[Compute.scala 136:13]
        printf(clock, UInt<1>(1), "slice inputs1: %d \n", _T_174) @[Compute.scala 136:13]
        skip @[Compute.scala 136:13]
      node _T_178 = bits(io.mem.rd.bits, 39, 32) @[Compute.scala 135:32]
      reg1[4] <= _T_178 @[Compute.scala 135:15]
      node _T_179 = bits(io.mem.rd.bits, 39, 32) @[Compute.scala 136:52]
      node _T_180 = bits(reset, 0, 0) @[Compute.scala 136:13]
      node _T_182 = eq(_T_180, UInt<1>("h00")) @[Compute.scala 136:13]
      when _T_182 : @[Compute.scala 136:13]
        printf(clock, UInt<1>(1), "slice inputs1: %d \n", _T_179) @[Compute.scala 136:13]
        skip @[Compute.scala 136:13]
      node _T_183 = bits(io.mem.rd.bits, 47, 40) @[Compute.scala 135:32]
      reg1[5] <= _T_183 @[Compute.scala 135:15]
      node _T_184 = bits(io.mem.rd.bits, 47, 40) @[Compute.scala 136:52]
      node _T_185 = bits(reset, 0, 0) @[Compute.scala 136:13]
      node _T_187 = eq(_T_185, UInt<1>("h00")) @[Compute.scala 136:13]
      when _T_187 : @[Compute.scala 136:13]
        printf(clock, UInt<1>(1), "slice inputs1: %d \n", _T_184) @[Compute.scala 136:13]
        skip @[Compute.scala 136:13]
      node _T_188 = bits(io.mem.rd.bits, 55, 48) @[Compute.scala 135:32]
      reg1[6] <= _T_188 @[Compute.scala 135:15]
      node _T_189 = bits(io.mem.rd.bits, 55, 48) @[Compute.scala 136:52]
      node _T_190 = bits(reset, 0, 0) @[Compute.scala 136:13]
      node _T_192 = eq(_T_190, UInt<1>("h00")) @[Compute.scala 136:13]
      when _T_192 : @[Compute.scala 136:13]
        printf(clock, UInt<1>(1), "slice inputs1: %d \n", _T_189) @[Compute.scala 136:13]
        skip @[Compute.scala 136:13]
      node _T_193 = bits(io.mem.rd.bits, 63, 56) @[Compute.scala 135:32]
      reg1[7] <= _T_193 @[Compute.scala 135:15]
      node _T_194 = bits(io.mem.rd.bits, 63, 56) @[Compute.scala 136:52]
      node _T_195 = bits(reset, 0, 0) @[Compute.scala 136:13]
      node _T_197 = eq(_T_195, UInt<1>("h00")) @[Compute.scala 136:13]
      when _T_197 : @[Compute.scala 136:13]
        printf(clock, UInt<1>(1), "slice inputs1: %d \n", _T_194) @[Compute.scala 136:13]
        skip @[Compute.scala 136:13]
      skip @[Compute.scala 133:50]
    node _T_198 = eq(state, UInt<3>("h04")) @[Compute.scala 140:15]
    node _T_199 = and(_T_198, io.mem.rd.valid) @[Compute.scala 140:30]
    when _T_199 : @[Compute.scala 140:50]
      node _T_200 = bits(io.mem.rd.bits, 7, 0) @[Compute.scala 142:32]
      reg2[0] <= _T_200 @[Compute.scala 142:15]
      node _T_201 = bits(io.mem.rd.bits, 7, 0) @[Compute.scala 143:53]
      node _T_202 = bits(reset, 0, 0) @[Compute.scala 143:13]
      node _T_204 = eq(_T_202, UInt<1>("h00")) @[Compute.scala 143:13]
      when _T_204 : @[Compute.scala 143:13]
        printf(clock, UInt<1>(1), "slice inputs2: %d\n\n", _T_201) @[Compute.scala 143:13]
        skip @[Compute.scala 143:13]
      node _T_205 = bits(io.mem.rd.bits, 15, 8) @[Compute.scala 142:32]
      reg2[1] <= _T_205 @[Compute.scala 142:15]
      node _T_206 = bits(io.mem.rd.bits, 15, 8) @[Compute.scala 143:53]
      node _T_207 = bits(reset, 0, 0) @[Compute.scala 143:13]
      node _T_209 = eq(_T_207, UInt<1>("h00")) @[Compute.scala 143:13]
      when _T_209 : @[Compute.scala 143:13]
        printf(clock, UInt<1>(1), "slice inputs2: %d\n\n", _T_206) @[Compute.scala 143:13]
        skip @[Compute.scala 143:13]
      node _T_210 = bits(io.mem.rd.bits, 23, 16) @[Compute.scala 142:32]
      reg2[2] <= _T_210 @[Compute.scala 142:15]
      node _T_211 = bits(io.mem.rd.bits, 23, 16) @[Compute.scala 143:53]
      node _T_212 = bits(reset, 0, 0) @[Compute.scala 143:13]
      node _T_214 = eq(_T_212, UInt<1>("h00")) @[Compute.scala 143:13]
      when _T_214 : @[Compute.scala 143:13]
        printf(clock, UInt<1>(1), "slice inputs2: %d\n\n", _T_211) @[Compute.scala 143:13]
        skip @[Compute.scala 143:13]
      node _T_215 = bits(io.mem.rd.bits, 31, 24) @[Compute.scala 142:32]
      reg2[3] <= _T_215 @[Compute.scala 142:15]
      node _T_216 = bits(io.mem.rd.bits, 31, 24) @[Compute.scala 143:53]
      node _T_217 = bits(reset, 0, 0) @[Compute.scala 143:13]
      node _T_219 = eq(_T_217, UInt<1>("h00")) @[Compute.scala 143:13]
      when _T_219 : @[Compute.scala 143:13]
        printf(clock, UInt<1>(1), "slice inputs2: %d\n\n", _T_216) @[Compute.scala 143:13]
        skip @[Compute.scala 143:13]
      node _T_220 = bits(io.mem.rd.bits, 39, 32) @[Compute.scala 142:32]
      reg2[4] <= _T_220 @[Compute.scala 142:15]
      node _T_221 = bits(io.mem.rd.bits, 39, 32) @[Compute.scala 143:53]
      node _T_222 = bits(reset, 0, 0) @[Compute.scala 143:13]
      node _T_224 = eq(_T_222, UInt<1>("h00")) @[Compute.scala 143:13]
      when _T_224 : @[Compute.scala 143:13]
        printf(clock, UInt<1>(1), "slice inputs2: %d\n\n", _T_221) @[Compute.scala 143:13]
        skip @[Compute.scala 143:13]
      node _T_225 = bits(io.mem.rd.bits, 47, 40) @[Compute.scala 142:32]
      reg2[5] <= _T_225 @[Compute.scala 142:15]
      node _T_226 = bits(io.mem.rd.bits, 47, 40) @[Compute.scala 143:53]
      node _T_227 = bits(reset, 0, 0) @[Compute.scala 143:13]
      node _T_229 = eq(_T_227, UInt<1>("h00")) @[Compute.scala 143:13]
      when _T_229 : @[Compute.scala 143:13]
        printf(clock, UInt<1>(1), "slice inputs2: %d\n\n", _T_226) @[Compute.scala 143:13]
        skip @[Compute.scala 143:13]
      node _T_230 = bits(io.mem.rd.bits, 55, 48) @[Compute.scala 142:32]
      reg2[6] <= _T_230 @[Compute.scala 142:15]
      node _T_231 = bits(io.mem.rd.bits, 55, 48) @[Compute.scala 143:53]
      node _T_232 = bits(reset, 0, 0) @[Compute.scala 143:13]
      node _T_234 = eq(_T_232, UInt<1>("h00")) @[Compute.scala 143:13]
      when _T_234 : @[Compute.scala 143:13]
        printf(clock, UInt<1>(1), "slice inputs2: %d\n\n", _T_231) @[Compute.scala 143:13]
        skip @[Compute.scala 143:13]
      node _T_235 = bits(io.mem.rd.bits, 63, 56) @[Compute.scala 142:32]
      reg2[7] <= _T_235 @[Compute.scala 142:15]
      node _T_236 = bits(io.mem.rd.bits, 63, 56) @[Compute.scala 143:53]
      node _T_237 = bits(reset, 0, 0) @[Compute.scala 143:13]
      node _T_239 = eq(_T_237, UInt<1>("h00")) @[Compute.scala 143:13]
      when _T_239 : @[Compute.scala 143:13]
        printf(clock, UInt<1>(1), "slice inputs2: %d\n\n", _T_236) @[Compute.scala 143:13]
        skip @[Compute.scala 143:13]
      skip @[Compute.scala 140:50]
    node _T_240 = eq(state, UInt<3>("h02")) @[Compute.scala 147:28]
    node _T_241 = eq(state, UInt<3>("h04")) @[Compute.scala 147:51]
    node _T_242 = or(_T_240, _T_241) @[Compute.scala 147:43]
    io.mem.rd.ready <= _T_242 @[Compute.scala 147:19]
    inst dot of Dot @[Compute.scala 150:19]
    dot.clock <= clock
    dot.reset <= reset
    inst overallAccum of Accumulator @[Compute.scala 151:28]
    overallAccum.clock <= clock
    overallAccum.reset <= reset
    node _T_243 = dshl(dot.io.res, shift) @[Compute.scala 152:37]
    reg shiftReg : UInt, clock @[Compute.scala 152:25]
    shiftReg <= _T_243 @[Compute.scala 152:25]
    reg validReg : UInt<1>, clock @[Compute.scala 153:25]
    validReg <= dot.io.valid @[Compute.scala 153:25]
    node _T_246 = eq(state, UInt<3>("h05")) @[Compute.scala 155:25]
    node _T_247 = and(_T_246, last) @[Compute.scala 155:39]
    dot.io.start <= _T_247 @[Compute.scala 155:16]
    dot.io.arrA[0] <= reg1[0] @[Compute.scala 156:15]
    dot.io.arrA[1] <= reg1[1] @[Compute.scala 156:15]
    dot.io.arrA[2] <= reg1[2] @[Compute.scala 156:15]
    dot.io.arrA[3] <= reg1[3] @[Compute.scala 156:15]
    dot.io.arrA[4] <= reg1[4] @[Compute.scala 156:15]
    dot.io.arrA[5] <= reg1[5] @[Compute.scala 156:15]
    dot.io.arrA[6] <= reg1[6] @[Compute.scala 156:15]
    dot.io.arrA[7] <= reg1[7] @[Compute.scala 156:15]
    dot.io.arrB[0] <= reg2[0] @[Compute.scala 157:15]
    dot.io.arrB[1] <= reg2[1] @[Compute.scala 157:15]
    dot.io.arrB[2] <= reg2[2] @[Compute.scala 157:15]
    dot.io.arrB[3] <= reg2[3] @[Compute.scala 157:15]
    dot.io.arrB[4] <= reg2[4] @[Compute.scala 157:15]
    dot.io.arrB[5] <= reg2[5] @[Compute.scala 157:15]
    dot.io.arrB[6] <= reg2[6] @[Compute.scala 157:15]
    dot.io.arrB[7] <= reg2[7] @[Compute.scala 157:15]
    overallAccum.io.rst <= io.vals[2] @[Compute.scala 158:23]
    overallAccum.io.valid <= validReg @[Compute.scala 159:25]
    overallAccum.io.in <= shiftReg @[Compute.scala 160:22]
    io.mem.wr.valid <= overallAccum.io.ready @[Compute.scala 163:19]
    io.mem.wr.bits <= overallAccum.io.sum @[Compute.scala 164:18]
    node _T_248 = eq(state, UInt<3>("h00")) @[Compute.scala 167:15]
    when _T_248 : @[Compute.scala 167:26]
      cnt <= UInt<1>("h00") @[Compute.scala 168:9]
      skip @[Compute.scala 167:26]
    else : @[Compute.scala 169:38]
      node _T_250 = eq(state, UInt<3>("h06")) @[Compute.scala 169:22]
      when _T_250 : @[Compute.scala 169:38]
        node _T_252 = add(cnt, UInt<1>("h01")) @[Compute.scala 170:16]
        node _T_253 = tail(_T_252, 1) @[Compute.scala 170:16]
        cnt <= _T_253 @[Compute.scala 170:9]
        skip @[Compute.scala 169:38]
    io.finish <= overallAccum.io.ready @[Compute.scala 175:13]
    
  module Accel : 
    input clock : Clock
    input reset : UInt<1>
    output io : {host : {req : {flip valid : UInt<1>, flip opcode : UInt<1>, flip addr : UInt<8>, flip value : UInt<32>, deq : UInt<1>}, resp : {valid : UInt<1>, bits : UInt<32>}}, mem : {req : {valid : UInt<1>, opcode : UInt<1>, len : UInt<8>, addr : UInt<64>}, wr : {valid : UInt<1>, bits : UInt<64>}, flip rd : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<64>}}}
    
    inst rf of RegFile @[Accel.scala 53:18]
    rf.clock <= clock
    rf.reset <= reset
    inst ce of Compute @[Accel.scala 54:18]
    ce.clock <= clock
    ce.reset <= reset
    io.host.resp.bits <= rf.io.host.resp.bits @[Accel.scala 55:14]
    io.host.resp.valid <= rf.io.host.resp.valid @[Accel.scala 55:14]
    io.host.req.deq <= rf.io.host.req.deq @[Accel.scala 55:14]
    rf.io.host.req.value <= io.host.req.value @[Accel.scala 55:14]
    rf.io.host.req.addr <= io.host.req.addr @[Accel.scala 55:14]
    rf.io.host.req.opcode <= io.host.req.opcode @[Accel.scala 55:14]
    rf.io.host.req.valid <= io.host.req.valid @[Accel.scala 55:14]
    ce.io.mem.rd.bits <= io.mem.rd.bits @[Accel.scala 56:10]
    ce.io.mem.rd.valid <= io.mem.rd.valid @[Accel.scala 56:10]
    io.mem.rd.ready <= ce.io.mem.rd.ready @[Accel.scala 56:10]
    io.mem.wr.bits <= ce.io.mem.wr.bits @[Accel.scala 56:10]
    io.mem.wr.valid <= ce.io.mem.wr.valid @[Accel.scala 56:10]
    io.mem.req.addr <= ce.io.mem.req.addr @[Accel.scala 56:10]
    io.mem.req.len <= ce.io.mem.req.len @[Accel.scala 56:10]
    io.mem.req.opcode <= ce.io.mem.req.opcode @[Accel.scala 56:10]
    io.mem.req.valid <= ce.io.mem.req.valid @[Accel.scala 56:10]
    ce.io.launch <= rf.io.launch @[Accel.scala 57:16]
    rf.io.finish <= ce.io.finish @[Accel.scala 58:16]
    rf.io.ecnt[0].bits <= ce.io.ecnt[0].bits @[Accel.scala 59:14]
    rf.io.ecnt[0].valid <= ce.io.ecnt[0].valid @[Accel.scala 59:14]
    ce.io.vals[0] <= rf.io.vals[0] @[Accel.scala 60:14]
    ce.io.vals[1] <= rf.io.vals[1] @[Accel.scala 60:14]
    ce.io.vals[2] <= rf.io.vals[2] @[Accel.scala 60:14]
    ce.io.vals[3] <= rf.io.vals[3] @[Accel.scala 60:14]
    ce.io.ptrs[0] <= rf.io.ptrs[0] @[Accel.scala 61:14]
    ce.io.ptrs[1] <= rf.io.ptrs[1] @[Accel.scala 61:14]
    ce.io.ptrs[2] <= rf.io.ptrs[2] @[Accel.scala 61:14]
    
  module TestAccel : 
    input clock : Clock
    input reset : UInt<1>
    input sim_clock : Clock
    output sim_wait : UInt<1>
    
    inst sim_shell of VTASimShell @[TestAccel.scala 59:25]
    sim_shell.clock <= clock
    sim_shell.reset <= reset
    inst vta_accel of Accel @[TestAccel.scala 60:25]
    vta_accel.clock <= clock
    vta_accel.reset <= reset
    sim_shell.sim_clock <= sim_clock @[TestAccel.scala 61:23]
    sim_wait <= sim_shell.sim_wait @[TestAccel.scala 62:12]
    vta_accel.io.mem.rd.bits <= sim_shell.mem.rd.bits @[TestAccel.scala 63:17]
    vta_accel.io.mem.rd.valid <= sim_shell.mem.rd.valid @[TestAccel.scala 63:17]
    sim_shell.mem.rd.ready <= vta_accel.io.mem.rd.ready @[TestAccel.scala 63:17]
    sim_shell.mem.wr.bits <= vta_accel.io.mem.wr.bits @[TestAccel.scala 63:17]
    sim_shell.mem.wr.valid <= vta_accel.io.mem.wr.valid @[TestAccel.scala 63:17]
    sim_shell.mem.req.addr <= vta_accel.io.mem.req.addr @[TestAccel.scala 63:17]
    sim_shell.mem.req.len <= vta_accel.io.mem.req.len @[TestAccel.scala 63:17]
    sim_shell.mem.req.opcode <= vta_accel.io.mem.req.opcode @[TestAccel.scala 63:17]
    sim_shell.mem.req.valid <= vta_accel.io.mem.req.valid @[TestAccel.scala 63:17]
    sim_shell.host.resp.bits <= vta_accel.io.host.resp.bits @[TestAccel.scala 64:21]
    sim_shell.host.resp.valid <= vta_accel.io.host.resp.valid @[TestAccel.scala 64:21]
    sim_shell.host.req.deq <= vta_accel.io.host.req.deq @[TestAccel.scala 64:21]
    vta_accel.io.host.req.value <= sim_shell.host.req.value @[TestAccel.scala 64:21]
    vta_accel.io.host.req.addr <= sim_shell.host.req.addr @[TestAccel.scala 64:21]
    vta_accel.io.host.req.opcode <= sim_shell.host.req.opcode @[TestAccel.scala 64:21]
    vta_accel.io.host.req.valid <= sim_shell.host.req.valid @[TestAccel.scala 64:21]
    
