;buildInfoPackage: chisel3, version: 3.1.7, scalaVersion: 2.11.12, sbtVersion: 1.1.1, builtAtString: 2019-03-20 22:15:13.399, builtAtMillis: 1553120113399
circuit TestAccel : 
  extmodule VTASimDPI : 
    output dpi_wait : UInt<1>
    input reset : UInt<1>
    input clock : Clock
    
    defname = VTASimDPI
    
    
  extmodule VTAHostDPI : 
    output dpi : {req : {valid : UInt<1>, opcode : UInt<1>, addr : UInt<8>, value : UInt<32>, flip deq : UInt<1>}, flip resp : {valid : UInt<1>, bits : UInt<32>}}
    input reset : UInt<1>
    input clock : Clock
    
    defname = VTAHostDPI
    
    
  extmodule VTAMemDPI : 
    output dpi : {req : {flip valid : UInt<1>, flip opcode : UInt<1>, flip len : UInt<8>, flip addr : UInt<64>}, flip wr : {valid : UInt<1>, bits : UInt<64>}, rd : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<64>}}
    input reset : UInt<1>
    input clock : Clock
    
    defname = VTAMemDPI
    
    
  module VTASimShell : 
    input clock : Clock
    input reset : UInt<1>
    output host : {req : {valid : UInt<1>, opcode : UInt<1>, addr : UInt<8>, value : UInt<32>, flip deq : UInt<1>}, flip resp : {valid : UInt<1>, bits : UInt<32>}}
    output mem : {req : {flip valid : UInt<1>, flip opcode : UInt<1>, flip len : UInt<8>, flip addr : UInt<64>}, flip wr : {valid : UInt<1>, bits : UInt<64>}, rd : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<64>}}
    input sim_clock : Clock
    output sim_wait : UInt<1>
    
    inst mod_sim of VTASimDPI @[TestAccel.scala 37:23]
    mod_sim.dpi_wait is invalid
    mod_sim.reset is invalid
    mod_sim.clock is invalid
    inst mod_host of VTAHostDPI @[TestAccel.scala 38:24]
    mod_host.dpi is invalid
    mod_host.reset is invalid
    mod_host.clock is invalid
    inst mod_mem of VTAMemDPI @[TestAccel.scala 39:23]
    mod_mem.dpi is invalid
    mod_mem.reset is invalid
    mod_mem.clock is invalid
    mod_mem.clock <= clock @[TestAccel.scala 40:20]
    mod_mem.reset <= reset @[TestAccel.scala 41:20]
    mem.rd.bits <= mod_mem.dpi.rd.bits @[TestAccel.scala 42:18]
    mem.rd.valid <= mod_mem.dpi.rd.valid @[TestAccel.scala 42:18]
    mod_mem.dpi.rd.ready <= mem.rd.ready @[TestAccel.scala 42:18]
    mod_mem.dpi.wr.bits <= mem.wr.bits @[TestAccel.scala 42:18]
    mod_mem.dpi.wr.valid <= mem.wr.valid @[TestAccel.scala 42:18]
    mod_mem.dpi.req.addr <= mem.req.addr @[TestAccel.scala 42:18]
    mod_mem.dpi.req.len <= mem.req.len @[TestAccel.scala 42:18]
    mod_mem.dpi.req.opcode <= mem.req.opcode @[TestAccel.scala 42:18]
    mod_mem.dpi.req.valid <= mem.req.valid @[TestAccel.scala 42:18]
    mod_host.clock <= clock @[TestAccel.scala 43:21]
    mod_host.reset <= reset @[TestAccel.scala 44:21]
    mod_host.dpi.resp.bits <= host.resp.bits @[TestAccel.scala 45:8]
    mod_host.dpi.resp.valid <= host.resp.valid @[TestAccel.scala 45:8]
    mod_host.dpi.req.deq <= host.req.deq @[TestAccel.scala 45:8]
    host.req.value <= mod_host.dpi.req.value @[TestAccel.scala 45:8]
    host.req.addr <= mod_host.dpi.req.addr @[TestAccel.scala 45:8]
    host.req.opcode <= mod_host.dpi.req.opcode @[TestAccel.scala 45:8]
    host.req.valid <= mod_host.dpi.req.valid @[TestAccel.scala 45:8]
    mod_sim.clock <= sim_clock @[TestAccel.scala 46:20]
    mod_sim.reset <= reset @[TestAccel.scala 47:20]
    sim_wait <= mod_sim.dpi_wait @[TestAccel.scala 48:12]
    
  module RegFile : 
    input clock : Clock
    input reset : UInt<1>
    output io : {launch : UInt<1>, flip finish : UInt<1>, flip ecnt : {valid : UInt<1>, bits : UInt<32>}[1], vals : UInt<32>[4], ptrs : UInt<64>[3], host : {req : {flip valid : UInt<1>, flip opcode : UInt<1>, flip addr : UInt<8>, flip value : UInt<32>, deq : UInt<1>}, resp : {valid : UInt<1>, bits : UInt<32>}}}
    
    reg state : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[RegFile.scala 64:22]
    node _T_74 = eq(UInt<1>("h00"), state) @[Conditional.scala 37:30]
    when _T_74 : @[Conditional.scala 40:58]
      node _T_76 = eq(io.host.req.opcode, UInt<1>("h00")) @[RegFile.scala 68:34]
      node _T_77 = and(io.host.req.valid, _T_76) @[RegFile.scala 68:31]
      when _T_77 : @[RegFile.scala 68:55]
        state <= UInt<1>("h01") @[RegFile.scala 69:15]
        skip @[RegFile.scala 68:55]
      skip @[Conditional.scala 40:58]
    else : @[Conditional.scala 39:67]
      node _T_78 = eq(UInt<1>("h01"), state) @[Conditional.scala 37:30]
      when _T_78 : @[Conditional.scala 39:67]
        state <= UInt<1>("h00") @[RegFile.scala 73:13]
        skip @[Conditional.scala 39:67]
    node _T_79 = eq(state, UInt<1>("h00")) @[RegFile.scala 77:28]
    node _T_80 = and(_T_79, io.host.req.valid) @[RegFile.scala 77:38]
    io.host.req.deq <= _T_80 @[RegFile.scala 77:19]
    wire _T_84 : UInt<32> @[RegFile.scala 80:50]
    _T_84 <= UInt<1>("h00") @[RegFile.scala 80:50]
    reg reg_0 : UInt, clock with : (reset => (reset, _T_84)) @[RegFile.scala 80:37]
    wire _T_89 : UInt<32> @[RegFile.scala 80:50]
    _T_89 <= UInt<1>("h00") @[RegFile.scala 80:50]
    reg reg_1 : UInt, clock with : (reset => (reset, _T_89)) @[RegFile.scala 80:37]
    wire _T_94 : UInt<32> @[RegFile.scala 80:50]
    _T_94 <= UInt<1>("h00") @[RegFile.scala 80:50]
    reg reg_2 : UInt, clock with : (reset => (reset, _T_94)) @[RegFile.scala 80:37]
    wire _T_99 : UInt<32> @[RegFile.scala 80:50]
    _T_99 <= UInt<1>("h00") @[RegFile.scala 80:50]
    reg reg_3 : UInt, clock with : (reset => (reset, _T_99)) @[RegFile.scala 80:37]
    wire _T_104 : UInt<32> @[RegFile.scala 80:50]
    _T_104 <= UInt<1>("h00") @[RegFile.scala 80:50]
    reg reg_4 : UInt, clock with : (reset => (reset, _T_104)) @[RegFile.scala 80:37]
    wire _T_109 : UInt<32> @[RegFile.scala 80:50]
    _T_109 <= UInt<1>("h00") @[RegFile.scala 80:50]
    reg reg_5 : UInt, clock with : (reset => (reset, _T_109)) @[RegFile.scala 80:37]
    wire _T_114 : UInt<32> @[RegFile.scala 80:50]
    _T_114 <= UInt<1>("h00") @[RegFile.scala 80:50]
    reg reg_6 : UInt, clock with : (reset => (reset, _T_114)) @[RegFile.scala 80:37]
    wire _T_119 : UInt<32> @[RegFile.scala 80:50]
    _T_119 <= UInt<1>("h00") @[RegFile.scala 80:50]
    reg reg_7 : UInt, clock with : (reset => (reset, _T_119)) @[RegFile.scala 80:37]
    wire _T_124 : UInt<32> @[RegFile.scala 80:50]
    _T_124 <= UInt<1>("h00") @[RegFile.scala 80:50]
    reg reg_8 : UInt, clock with : (reset => (reset, _T_124)) @[RegFile.scala 80:37]
    wire _T_129 : UInt<32> @[RegFile.scala 80:50]
    _T_129 <= UInt<1>("h00") @[RegFile.scala 80:50]
    reg reg_9 : UInt, clock with : (reset => (reset, _T_129)) @[RegFile.scala 80:37]
    wire _T_134 : UInt<32> @[RegFile.scala 80:50]
    _T_134 <= UInt<1>("h00") @[RegFile.scala 80:50]
    reg reg_10 : UInt, clock with : (reset => (reset, _T_134)) @[RegFile.scala 80:37]
    wire _T_139 : UInt<32> @[RegFile.scala 80:50]
    _T_139 <= UInt<1>("h00") @[RegFile.scala 80:50]
    reg reg_11 : UInt, clock with : (reset => (reset, _T_139)) @[RegFile.scala 80:37]
    when io.finish : @[RegFile.scala 87:20]
      reg_0 <= UInt<2>("h02") @[RegFile.scala 88:12]
      skip @[RegFile.scala 87:20]
    else : @[RegFile.scala 90:63]
      node _T_154 = eq(state, UInt<1>("h00")) @[RegFile.scala 89:22]
      node _T_155 = and(_T_154, io.host.req.valid) @[RegFile.scala 89:32]
      node _T_156 = and(_T_155, io.host.req.opcode) @[RegFile.scala 89:53]
      node _T_158 = eq(UInt<1>("h00"), io.host.req.addr) @[RegFile.scala 90:41]
      node _T_159 = and(_T_156, _T_158) @[RegFile.scala 90:28]
      when _T_159 : @[RegFile.scala 90:63]
        reg_0 <= io.host.req.value @[RegFile.scala 91:12]
        skip @[RegFile.scala 90:63]
    when io.ecnt[0].valid : @[RegFile.scala 95:29]
      reg_1 <= io.ecnt[0].bits @[RegFile.scala 96:19]
      skip @[RegFile.scala 95:29]
    else : @[RegFile.scala 98:70]
      node _T_160 = eq(state, UInt<1>("h00")) @[RegFile.scala 97:24]
      node _T_161 = and(_T_160, io.host.req.valid) @[RegFile.scala 97:34]
      node _T_162 = and(_T_161, io.host.req.opcode) @[RegFile.scala 97:55]
      node _T_164 = eq(UInt<3>("h04"), io.host.req.addr) @[RegFile.scala 98:48]
      node _T_165 = and(_T_162, _T_164) @[RegFile.scala 98:30]
      when _T_165 : @[RegFile.scala 98:70]
        reg_1 <= io.host.req.value @[RegFile.scala 99:19]
        skip @[RegFile.scala 98:70]
    node _T_166 = eq(state, UInt<1>("h00")) @[RegFile.scala 104:17]
    node _T_167 = and(_T_166, io.host.req.valid) @[RegFile.scala 104:27]
    node _T_168 = and(_T_167, io.host.req.opcode) @[RegFile.scala 104:48]
    node _T_170 = eq(UInt<4>("h08"), io.host.req.addr) @[RegFile.scala 105:48]
    node _T_171 = and(_T_168, _T_170) @[RegFile.scala 105:30]
    when _T_171 : @[RegFile.scala 105:70]
      reg_2 <= io.host.req.value @[RegFile.scala 106:19]
      skip @[RegFile.scala 105:70]
    node _T_172 = eq(state, UInt<1>("h00")) @[RegFile.scala 104:17]
    node _T_173 = and(_T_172, io.host.req.valid) @[RegFile.scala 104:27]
    node _T_174 = and(_T_173, io.host.req.opcode) @[RegFile.scala 104:48]
    node _T_176 = eq(UInt<4>("h0c"), io.host.req.addr) @[RegFile.scala 105:48]
    node _T_177 = and(_T_174, _T_176) @[RegFile.scala 105:30]
    when _T_177 : @[RegFile.scala 105:70]
      reg_3 <= io.host.req.value @[RegFile.scala 106:19]
      skip @[RegFile.scala 105:70]
    node _T_178 = eq(state, UInt<1>("h00")) @[RegFile.scala 104:17]
    node _T_179 = and(_T_178, io.host.req.valid) @[RegFile.scala 104:27]
    node _T_180 = and(_T_179, io.host.req.opcode) @[RegFile.scala 104:48]
    node _T_182 = eq(UInt<5>("h010"), io.host.req.addr) @[RegFile.scala 105:48]
    node _T_183 = and(_T_180, _T_182) @[RegFile.scala 105:30]
    when _T_183 : @[RegFile.scala 105:70]
      reg_4 <= io.host.req.value @[RegFile.scala 106:19]
      skip @[RegFile.scala 105:70]
    node _T_184 = eq(state, UInt<1>("h00")) @[RegFile.scala 104:17]
    node _T_185 = and(_T_184, io.host.req.valid) @[RegFile.scala 104:27]
    node _T_186 = and(_T_185, io.host.req.opcode) @[RegFile.scala 104:48]
    node _T_188 = eq(UInt<5>("h014"), io.host.req.addr) @[RegFile.scala 105:48]
    node _T_189 = and(_T_186, _T_188) @[RegFile.scala 105:30]
    when _T_189 : @[RegFile.scala 105:70]
      reg_5 <= io.host.req.value @[RegFile.scala 106:19]
      skip @[RegFile.scala 105:70]
    node _T_190 = eq(state, UInt<1>("h00")) @[RegFile.scala 104:17]
    node _T_191 = and(_T_190, io.host.req.valid) @[RegFile.scala 104:27]
    node _T_192 = and(_T_191, io.host.req.opcode) @[RegFile.scala 104:48]
    node _T_194 = eq(UInt<5>("h018"), io.host.req.addr) @[RegFile.scala 105:48]
    node _T_195 = and(_T_192, _T_194) @[RegFile.scala 105:30]
    when _T_195 : @[RegFile.scala 105:70]
      reg_6 <= io.host.req.value @[RegFile.scala 106:19]
      skip @[RegFile.scala 105:70]
    node _T_196 = eq(state, UInt<1>("h00")) @[RegFile.scala 104:17]
    node _T_197 = and(_T_196, io.host.req.valid) @[RegFile.scala 104:27]
    node _T_198 = and(_T_197, io.host.req.opcode) @[RegFile.scala 104:48]
    node _T_200 = eq(UInt<5>("h01c"), io.host.req.addr) @[RegFile.scala 105:48]
    node _T_201 = and(_T_198, _T_200) @[RegFile.scala 105:30]
    when _T_201 : @[RegFile.scala 105:70]
      reg_7 <= io.host.req.value @[RegFile.scala 106:19]
      skip @[RegFile.scala 105:70]
    node _T_202 = eq(state, UInt<1>("h00")) @[RegFile.scala 104:17]
    node _T_203 = and(_T_202, io.host.req.valid) @[RegFile.scala 104:27]
    node _T_204 = and(_T_203, io.host.req.opcode) @[RegFile.scala 104:48]
    node _T_206 = eq(UInt<6>("h020"), io.host.req.addr) @[RegFile.scala 105:48]
    node _T_207 = and(_T_204, _T_206) @[RegFile.scala 105:30]
    when _T_207 : @[RegFile.scala 105:70]
      reg_8 <= io.host.req.value @[RegFile.scala 106:19]
      skip @[RegFile.scala 105:70]
    node _T_208 = eq(state, UInt<1>("h00")) @[RegFile.scala 104:17]
    node _T_209 = and(_T_208, io.host.req.valid) @[RegFile.scala 104:27]
    node _T_210 = and(_T_209, io.host.req.opcode) @[RegFile.scala 104:48]
    node _T_212 = eq(UInt<6>("h024"), io.host.req.addr) @[RegFile.scala 105:48]
    node _T_213 = and(_T_210, _T_212) @[RegFile.scala 105:30]
    when _T_213 : @[RegFile.scala 105:70]
      reg_9 <= io.host.req.value @[RegFile.scala 106:19]
      skip @[RegFile.scala 105:70]
    node _T_214 = eq(state, UInt<1>("h00")) @[RegFile.scala 104:17]
    node _T_215 = and(_T_214, io.host.req.valid) @[RegFile.scala 104:27]
    node _T_216 = and(_T_215, io.host.req.opcode) @[RegFile.scala 104:48]
    node _T_218 = eq(UInt<6>("h028"), io.host.req.addr) @[RegFile.scala 105:48]
    node _T_219 = and(_T_216, _T_218) @[RegFile.scala 105:30]
    when _T_219 : @[RegFile.scala 105:70]
      reg_10 <= io.host.req.value @[RegFile.scala 106:19]
      skip @[RegFile.scala 105:70]
    node _T_220 = eq(state, UInt<1>("h00")) @[RegFile.scala 104:17]
    node _T_221 = and(_T_220, io.host.req.valid) @[RegFile.scala 104:27]
    node _T_222 = and(_T_221, io.host.req.opcode) @[RegFile.scala 104:48]
    node _T_224 = eq(UInt<6>("h02c"), io.host.req.addr) @[RegFile.scala 105:48]
    node _T_225 = and(_T_222, _T_224) @[RegFile.scala 105:30]
    when _T_225 : @[RegFile.scala 105:70]
      reg_11 <= io.host.req.value @[RegFile.scala 106:19]
      skip @[RegFile.scala 105:70]
    wire _T_229 : UInt<32> @[RegFile.scala 110:35]
    _T_229 <= UInt<1>("h00") @[RegFile.scala 110:35]
    reg rdata : UInt, clock with : (reset => (reset, _T_229)) @[RegFile.scala 110:22]
    node _T_231 = eq(state, UInt<1>("h00")) @[RegFile.scala 111:15]
    node _T_232 = and(_T_231, io.host.req.valid) @[RegFile.scala 111:25]
    node _T_234 = eq(io.host.req.opcode, UInt<1>("h00")) @[RegFile.scala 111:49]
    node _T_235 = and(_T_232, _T_234) @[RegFile.scala 111:46]
    when _T_235 : @[RegFile.scala 111:70]
      node _T_237 = eq(UInt<6>("h02c"), io.host.req.addr) @[Mux.scala 46:19]
      node _T_238 = mux(_T_237, reg_11, UInt<1>("h00")) @[Mux.scala 46:16]
      node _T_239 = eq(UInt<6>("h028"), io.host.req.addr) @[Mux.scala 46:19]
      node _T_240 = mux(_T_239, reg_10, _T_238) @[Mux.scala 46:16]
      node _T_241 = eq(UInt<6>("h024"), io.host.req.addr) @[Mux.scala 46:19]
      node _T_242 = mux(_T_241, reg_9, _T_240) @[Mux.scala 46:16]
      node _T_243 = eq(UInt<6>("h020"), io.host.req.addr) @[Mux.scala 46:19]
      node _T_244 = mux(_T_243, reg_8, _T_242) @[Mux.scala 46:16]
      node _T_245 = eq(UInt<5>("h01c"), io.host.req.addr) @[Mux.scala 46:19]
      node _T_246 = mux(_T_245, reg_7, _T_244) @[Mux.scala 46:16]
      node _T_247 = eq(UInt<5>("h018"), io.host.req.addr) @[Mux.scala 46:19]
      node _T_248 = mux(_T_247, reg_6, _T_246) @[Mux.scala 46:16]
      node _T_249 = eq(UInt<5>("h014"), io.host.req.addr) @[Mux.scala 46:19]
      node _T_250 = mux(_T_249, reg_5, _T_248) @[Mux.scala 46:16]
      node _T_251 = eq(UInt<5>("h010"), io.host.req.addr) @[Mux.scala 46:19]
      node _T_252 = mux(_T_251, reg_4, _T_250) @[Mux.scala 46:16]
      node _T_253 = eq(UInt<4>("h0c"), io.host.req.addr) @[Mux.scala 46:19]
      node _T_254 = mux(_T_253, reg_3, _T_252) @[Mux.scala 46:16]
      node _T_255 = eq(UInt<4>("h08"), io.host.req.addr) @[Mux.scala 46:19]
      node _T_256 = mux(_T_255, reg_2, _T_254) @[Mux.scala 46:16]
      node _T_257 = eq(UInt<3>("h04"), io.host.req.addr) @[Mux.scala 46:19]
      node _T_258 = mux(_T_257, reg_1, _T_256) @[Mux.scala 46:16]
      node _T_259 = eq(UInt<1>("h00"), io.host.req.addr) @[Mux.scala 46:19]
      node _T_260 = mux(_T_259, reg_0, _T_258) @[Mux.scala 46:16]
      rdata <= _T_260 @[RegFile.scala 112:11]
      skip @[RegFile.scala 111:70]
    node _T_261 = eq(state, UInt<1>("h01")) @[RegFile.scala 115:31]
    io.host.resp.valid <= _T_261 @[RegFile.scala 115:22]
    io.host.resp.bits <= rdata @[RegFile.scala 116:21]
    node _T_262 = bits(reg_0, 0, 0) @[RegFile.scala 118:22]
    io.launch <= _T_262 @[RegFile.scala 118:13]
    io.vals[0] <= reg_2 @[RegFile.scala 121:16]
    io.vals[1] <= reg_3 @[RegFile.scala 121:16]
    io.vals[2] <= reg_4 @[RegFile.scala 121:16]
    io.vals[3] <= reg_5 @[RegFile.scala 121:16]
    node _T_263 = cat(reg_7, reg_6) @[Cat.scala 30:58]
    io.ptrs[0] <= _T_263 @[RegFile.scala 125:16]
    node _T_264 = cat(reg_9, reg_8) @[Cat.scala 30:58]
    io.ptrs[1] <= _T_264 @[RegFile.scala 125:16]
    node _T_265 = cat(reg_11, reg_10) @[Cat.scala 30:58]
    io.ptrs[2] <= _T_265 @[RegFile.scala 125:16]
    
  module Accumulator : 
    input clock : Clock
    input reset : UInt<1>
    output io : {flip rst : UInt<1>, flip valid : UInt<1>, ready : UInt<1>, flip in : UInt<63>, sum : UInt<64>}
    
    reg reg : UInt<64>, clock with : (reset => (reset, UInt<64>("h00"))) @[Compute.scala 185:20]
    when io.rst : @[Compute.scala 186:17]
      reg <= UInt<1>("h00") @[Compute.scala 187:9]
      skip @[Compute.scala 186:17]
    else : @[Compute.scala 188:26]
      when io.valid : @[Compute.scala 188:26]
        node _T_18 = add(reg, io.in) @[Compute.scala 189:16]
        reg <= _T_18 @[Compute.scala 189:9]
        node _T_19 = add(reg, io.in) @[Compute.scala 190:36]
        node _T_20 = bits(reset, 0, 0) @[Compute.scala 190:11]
        node _T_22 = eq(_T_20, UInt<1>("h00")) @[Compute.scala 190:11]
        when _T_22 : @[Compute.scala 190:11]
          printf(clock, UInt<1>(1), "slice sum: %d \n", _T_19) @[Compute.scala 190:11]
          skip @[Compute.scala 190:11]
        skip @[Compute.scala 188:26]
    reg _T_24 : UInt<1>, clock @[Compute.scala 194:32]
    _T_24 <= io.valid @[Compute.scala 194:32]
    node _T_25 = bits(reset, 0, 0) @[Compute.scala 194:9]
    node _T_27 = eq(_T_25, UInt<1>("h00")) @[Compute.scala 194:9]
    when _T_27 : @[Compute.scala 194:9]
      printf(clock, UInt<1>(1), "leave: %d\n", _T_24) @[Compute.scala 194:9]
      skip @[Compute.scala 194:9]
    reg ready : UInt<1>, clock @[Compute.scala 196:22]
    ready <= io.valid @[Compute.scala 196:22]
    io.ready <= ready @[Compute.scala 197:12]
    io.sum <= reg @[Compute.scala 198:10]
    
  module Accumulator_1 : 
    input clock : Clock
    input reset : UInt<1>
    output io : {flip rst : UInt<1>, flip valid : UInt<1>, ready : UInt<1>, flip in : UInt<63>, sum : UInt<64>}
    
    reg reg : UInt<64>, clock with : (reset => (reset, UInt<64>("h00"))) @[Compute.scala 185:20]
    when io.rst : @[Compute.scala 186:17]
      reg <= UInt<1>("h00") @[Compute.scala 187:9]
      skip @[Compute.scala 186:17]
    else : @[Compute.scala 188:26]
      when io.valid : @[Compute.scala 188:26]
        node _T_18 = add(reg, io.in) @[Compute.scala 189:16]
        reg <= _T_18 @[Compute.scala 189:9]
        node _T_19 = add(reg, io.in) @[Compute.scala 190:36]
        node _T_20 = bits(reset, 0, 0) @[Compute.scala 190:11]
        node _T_22 = eq(_T_20, UInt<1>("h00")) @[Compute.scala 190:11]
        when _T_22 : @[Compute.scala 190:11]
          printf(clock, UInt<1>(1), "slice sum: %d \n", _T_19) @[Compute.scala 190:11]
          skip @[Compute.scala 190:11]
        skip @[Compute.scala 188:26]
    reg _T_24 : UInt<1>, clock @[Compute.scala 194:32]
    _T_24 <= io.valid @[Compute.scala 194:32]
    node _T_25 = bits(reset, 0, 0) @[Compute.scala 194:9]
    node _T_27 = eq(_T_25, UInt<1>("h00")) @[Compute.scala 194:9]
    when _T_27 : @[Compute.scala 194:9]
      printf(clock, UInt<1>(1), "leave: %d\n", _T_24) @[Compute.scala 194:9]
      skip @[Compute.scala 194:9]
    reg ready : UInt<1>, clock @[Compute.scala 196:22]
    ready <= io.valid @[Compute.scala 196:22]
    io.ready <= ready @[Compute.scala 197:12]
    io.sum <= reg @[Compute.scala 198:10]
    
  module Compute : 
    input clock : Clock
    input reset : UInt<1>
    output io : {flip launch : UInt<1>, finish : UInt<1>, ecnt : {valid : UInt<1>, bits : UInt<32>}[1], flip vals : UInt<32>[4], flip ptrs : UInt<64>[3], mem : {req : {valid : UInt<1>, opcode : UInt<1>, len : UInt<8>, addr : UInt<64>}, wr : {valid : UInt<1>, bits : UInt<64>}, flip rd : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<64>}}}
    
    reg state : UInt<3>, clock with : (reset => (reset, UInt<3>("h00"))) @[Compute.scala 48:22]
    reg cycles : UInt<32>, clock with : (reset => (reset, UInt<32>("h00"))) @[Compute.scala 53:23]
    reg reg1 : UInt<64>, clock @[Compute.scala 54:17]
    reg reg2 : UInt<64>, clock @[Compute.scala 55:17]
    reg cnt : UInt<32>, clock @[Compute.scala 56:16]
    reg raddr1 : UInt<64>, clock @[Compute.scala 57:19]
    reg raddr2 : UInt<64>, clock @[Compute.scala 58:19]
    reg waddr : UInt<64>, clock @[Compute.scala 59:18]
    node _T_88 = eq(UInt<3>("h00"), state) @[Conditional.scala 37:30]
    when _T_88 : @[Conditional.scala 40:58]
      when io.launch : @[Compute.scala 69:24]
        state <= UInt<3>("h01") @[Compute.scala 70:15]
        skip @[Compute.scala 69:24]
      skip @[Conditional.scala 40:58]
    else : @[Conditional.scala 39:67]
      node _T_89 = eq(UInt<3>("h01"), state) @[Conditional.scala 37:30]
      when _T_89 : @[Conditional.scala 39:67]
        state <= UInt<3>("h02") @[Compute.scala 75:13]
        skip @[Conditional.scala 39:67]
      else : @[Conditional.scala 39:67]
        node _T_90 = eq(UInt<3>("h02"), state) @[Conditional.scala 37:30]
        when _T_90 : @[Conditional.scala 39:67]
          when io.mem.rd.valid : @[Compute.scala 78:30]
            state <= UInt<3>("h03") @[Compute.scala 79:15]
            skip @[Compute.scala 78:30]
          skip @[Conditional.scala 39:67]
        else : @[Conditional.scala 39:67]
          node _T_91 = eq(UInt<3>("h03"), state) @[Conditional.scala 37:30]
          when _T_91 : @[Conditional.scala 39:67]
            state <= UInt<3>("h04") @[Compute.scala 83:13]
            skip @[Conditional.scala 39:67]
          else : @[Conditional.scala 39:67]
            node _T_92 = eq(UInt<3>("h04"), state) @[Conditional.scala 37:30]
            when _T_92 : @[Conditional.scala 39:67]
              when io.mem.rd.valid : @[Compute.scala 86:30]
                state <= UInt<3>("h05") @[Compute.scala 87:15]
                skip @[Compute.scala 86:30]
              skip @[Conditional.scala 39:67]
            else : @[Conditional.scala 39:67]
              node _T_93 = eq(UInt<3>("h05"), state) @[Conditional.scala 37:30]
              when _T_93 : @[Conditional.scala 39:67]
                state <= UInt<3>("h06") @[Compute.scala 92:13]
                skip @[Conditional.scala 39:67]
              else : @[Conditional.scala 39:67]
                node _T_94 = eq(UInt<3>("h06"), state) @[Conditional.scala 37:30]
                when _T_94 : @[Conditional.scala 39:67]
                  node _T_96 = sub(io.vals[1], UInt<1>("h01")) @[Compute.scala 95:29]
                  node _T_97 = asUInt(_T_96) @[Compute.scala 95:29]
                  node _T_98 = tail(_T_97, 1) @[Compute.scala 95:29]
                  node _T_99 = eq(cnt, _T_98) @[Compute.scala 95:17]
                  when _T_99 : @[Compute.scala 95:37]
                    state <= UInt<3>("h00") @[Compute.scala 96:15]
                    skip @[Compute.scala 95:37]
                  else : @[Compute.scala 97:20]
                    state <= UInt<3>("h01") @[Compute.scala 98:15]
                    skip @[Compute.scala 97:20]
                  skip @[Conditional.scala 39:67]
    node _T_100 = eq(state, UInt<3>("h06")) @[Compute.scala 103:20]
    node _T_102 = sub(io.vals[1], UInt<1>("h01")) @[Compute.scala 103:54]
    node _T_103 = asUInt(_T_102) @[Compute.scala 103:54]
    node _T_104 = tail(_T_103, 1) @[Compute.scala 103:54]
    node _T_105 = eq(cnt, _T_104) @[Compute.scala 103:42]
    node last = and(_T_100, _T_105) @[Compute.scala 103:35]
    node _T_106 = eq(state, UInt<3>("h00")) @[Compute.scala 106:15]
    when _T_106 : @[Compute.scala 106:26]
      cycles <= UInt<1>("h00") @[Compute.scala 107:12]
      skip @[Compute.scala 106:26]
    else : @[Compute.scala 108:16]
      node _T_109 = add(cycles, UInt<1>("h01")) @[Compute.scala 109:22]
      node _T_110 = tail(_T_109, 1) @[Compute.scala 109:22]
      cycles <= _T_110 @[Compute.scala 109:12]
      skip @[Compute.scala 108:16]
    io.ecnt[0].valid <= last @[Compute.scala 112:20]
    io.ecnt[0].bits <= cycles @[Compute.scala 113:19]
    node _T_111 = eq(state, UInt<3>("h00")) @[Compute.scala 116:15]
    when _T_111 : @[Compute.scala 116:26]
      raddr1 <= io.ptrs[0] @[Compute.scala 117:12]
      raddr2 <= io.ptrs[1] @[Compute.scala 118:12]
      waddr <= io.ptrs[2] @[Compute.scala 119:11]
      skip @[Compute.scala 116:26]
    else : @[Compute.scala 120:38]
      node _T_112 = eq(state, UInt<3>("h06")) @[Compute.scala 120:22]
      when _T_112 : @[Compute.scala 120:38]
        node _T_114 = add(raddr1, UInt<1>("h01")) @[Compute.scala 121:22]
        node _T_115 = tail(_T_114, 1) @[Compute.scala 121:22]
        raddr1 <= _T_115 @[Compute.scala 121:12]
        node _T_117 = add(raddr2, UInt<1>("h01")) @[Compute.scala 122:22]
        node _T_118 = tail(_T_117, 1) @[Compute.scala 122:22]
        raddr2 <= _T_118 @[Compute.scala 122:12]
        skip @[Compute.scala 120:38]
    node _T_119 = eq(state, UInt<3>("h01")) @[Compute.scala 127:29]
    node _T_120 = eq(state, UInt<3>("h03")) @[Compute.scala 127:51]
    node _T_121 = or(_T_119, _T_120) @[Compute.scala 127:43]
    node _T_122 = eq(state, UInt<3>("h05")) @[Compute.scala 127:73]
    node _T_123 = or(_T_121, _T_122) @[Compute.scala 127:65]
    io.mem.req.valid <= _T_123 @[Compute.scala 127:20]
    node _T_124 = eq(state, UInt<3>("h05")) @[Compute.scala 128:30]
    io.mem.req.opcode <= _T_124 @[Compute.scala 128:21]
    io.mem.req.len <= UInt<1>("h00") @[Compute.scala 129:18]
    node _T_126 = eq(state, UInt<3>("h01")) @[Compute.scala 130:32]
    node _T_127 = eq(state, UInt<3>("h03")) @[Compute.scala 130:54]
    node _T_128 = or(_T_126, _T_127) @[Compute.scala 130:46]
    node _T_129 = eq(state, UInt<3>("h01")) @[Compute.scala 130:79]
    node _T_130 = mux(_T_129, raddr1, raddr2) @[Compute.scala 130:72]
    node _T_131 = mux(_T_128, _T_130, waddr) @[Compute.scala 130:25]
    io.mem.req.addr <= _T_131 @[Compute.scala 130:19]
    node _T_132 = eq(state, UInt<3>("h02")) @[Compute.scala 133:15]
    node _T_133 = and(_T_132, io.mem.rd.valid) @[Compute.scala 133:30]
    when _T_133 : @[Compute.scala 133:50]
      node _T_134 = bits(io.mem.rd.bits, 7, 0) @[Compute.scala 134:27]
      reg1 <= _T_134 @[Compute.scala 134:10]
      node _T_135 = bits(io.mem.rd.bits, 7, 0) @[Compute.scala 135:50]
      node _T_136 = bits(reset, 0, 0) @[Compute.scala 135:11]
      node _T_138 = eq(_T_136, UInt<1>("h00")) @[Compute.scala 135:11]
      when _T_138 : @[Compute.scala 135:11]
        printf(clock, UInt<1>(1), "slice inputs1: %d \n", _T_135) @[Compute.scala 135:11]
        skip @[Compute.scala 135:11]
      skip @[Compute.scala 133:50]
    node _T_139 = eq(state, UInt<3>("h04")) @[Compute.scala 138:15]
    node _T_140 = and(_T_139, io.mem.rd.valid) @[Compute.scala 138:30]
    when _T_140 : @[Compute.scala 138:50]
      node _T_141 = bits(io.mem.rd.bits, 7, 0) @[Compute.scala 139:27]
      reg2 <= _T_141 @[Compute.scala 139:10]
      node _T_142 = bits(io.mem.rd.bits, 7, 0) @[Compute.scala 140:51]
      node _T_143 = bits(reset, 0, 0) @[Compute.scala 140:11]
      node _T_145 = eq(_T_143, UInt<1>("h00")) @[Compute.scala 140:11]
      when _T_145 : @[Compute.scala 140:11]
        printf(clock, UInt<1>(1), "slice inputs2: %d\n\n", _T_142) @[Compute.scala 140:11]
        skip @[Compute.scala 140:11]
      skip @[Compute.scala 138:50]
    node _T_146 = eq(state, UInt<3>("h02")) @[Compute.scala 143:28]
    node _T_147 = eq(state, UInt<3>("h04")) @[Compute.scala 143:51]
    node _T_148 = or(_T_146, _T_147) @[Compute.scala 143:43]
    io.mem.rd.ready <= _T_148 @[Compute.scala 143:19]
    inst sliceAccum of Accumulator @[Compute.scala 146:26]
    sliceAccum.clock <= clock
    sliceAccum.reset <= reset
    inst overallAccum of Accumulator_1 @[Compute.scala 147:28]
    overallAccum.clock <= clock
    overallAccum.reset <= reset
    node _T_149 = eq(state, UInt<3>("h05")) @[Compute.scala 154:32]
    sliceAccum.io.valid <= _T_149 @[Compute.scala 154:23]
    node _T_150 = mul(reg1, reg2) @[Compute.scala 155:28]
    sliceAccum.io.in <= _T_150 @[Compute.scala 155:20]
    sliceAccum.io.rst <= io.vals[3] @[Compute.scala 156:21]
    overallAccum.io.rst <= io.vals[2] @[Compute.scala 157:23]
    overallAccum.io.valid <= last @[Compute.scala 158:25]
    node _T_151 = bits(io.vals[0], 7, 0) @[Compute.scala 159:51]
    node _T_152 = dshl(sliceAccum.io.sum, _T_151) @[Compute.scala 159:43]
    overallAccum.io.in <= _T_152 @[Compute.scala 159:22]
    node _T_153 = eq(state, UInt<3>("h06")) @[Compute.scala 162:28]
    io.mem.wr.valid <= _T_153 @[Compute.scala 162:19]
    io.mem.wr.bits <= overallAccum.io.sum @[Compute.scala 163:18]
    node _T_154 = eq(state, UInt<3>("h00")) @[Compute.scala 166:15]
    when _T_154 : @[Compute.scala 166:26]
      cnt <= UInt<1>("h00") @[Compute.scala 167:9]
      skip @[Compute.scala 166:26]
    else : @[Compute.scala 168:38]
      node _T_156 = eq(state, UInt<3>("h06")) @[Compute.scala 168:22]
      when _T_156 : @[Compute.scala 168:38]
        node _T_158 = add(cnt, UInt<1>("h01")) @[Compute.scala 169:16]
        node _T_159 = tail(_T_158, 1) @[Compute.scala 169:16]
        cnt <= _T_159 @[Compute.scala 169:9]
        skip @[Compute.scala 168:38]
    io.finish <= overallAccum.io.ready @[Compute.scala 173:13]
    
  module Accel : 
    input clock : Clock
    input reset : UInt<1>
    output io : {host : {req : {flip valid : UInt<1>, flip opcode : UInt<1>, flip addr : UInt<8>, flip value : UInt<32>, deq : UInt<1>}, resp : {valid : UInt<1>, bits : UInt<32>}}, mem : {req : {valid : UInt<1>, opcode : UInt<1>, len : UInt<8>, addr : UInt<64>}, wr : {valid : UInt<1>, bits : UInt<64>}, flip rd : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<64>}}}
    
    inst rf of RegFile @[Accel.scala 53:18]
    rf.clock <= clock
    rf.reset <= reset
    inst ce of Compute @[Accel.scala 54:18]
    ce.clock <= clock
    ce.reset <= reset
    io.host.resp.bits <= rf.io.host.resp.bits @[Accel.scala 55:14]
    io.host.resp.valid <= rf.io.host.resp.valid @[Accel.scala 55:14]
    io.host.req.deq <= rf.io.host.req.deq @[Accel.scala 55:14]
    rf.io.host.req.value <= io.host.req.value @[Accel.scala 55:14]
    rf.io.host.req.addr <= io.host.req.addr @[Accel.scala 55:14]
    rf.io.host.req.opcode <= io.host.req.opcode @[Accel.scala 55:14]
    rf.io.host.req.valid <= io.host.req.valid @[Accel.scala 55:14]
    ce.io.mem.rd.bits <= io.mem.rd.bits @[Accel.scala 56:10]
    ce.io.mem.rd.valid <= io.mem.rd.valid @[Accel.scala 56:10]
    io.mem.rd.ready <= ce.io.mem.rd.ready @[Accel.scala 56:10]
    io.mem.wr.bits <= ce.io.mem.wr.bits @[Accel.scala 56:10]
    io.mem.wr.valid <= ce.io.mem.wr.valid @[Accel.scala 56:10]
    io.mem.req.addr <= ce.io.mem.req.addr @[Accel.scala 56:10]
    io.mem.req.len <= ce.io.mem.req.len @[Accel.scala 56:10]
    io.mem.req.opcode <= ce.io.mem.req.opcode @[Accel.scala 56:10]
    io.mem.req.valid <= ce.io.mem.req.valid @[Accel.scala 56:10]
    ce.io.launch <= rf.io.launch @[Accel.scala 57:16]
    rf.io.finish <= ce.io.finish @[Accel.scala 58:16]
    rf.io.ecnt[0].bits <= ce.io.ecnt[0].bits @[Accel.scala 59:14]
    rf.io.ecnt[0].valid <= ce.io.ecnt[0].valid @[Accel.scala 59:14]
    ce.io.vals[0] <= rf.io.vals[0] @[Accel.scala 60:14]
    ce.io.vals[1] <= rf.io.vals[1] @[Accel.scala 60:14]
    ce.io.vals[2] <= rf.io.vals[2] @[Accel.scala 60:14]
    ce.io.vals[3] <= rf.io.vals[3] @[Accel.scala 60:14]
    ce.io.ptrs[0] <= rf.io.ptrs[0] @[Accel.scala 61:14]
    ce.io.ptrs[1] <= rf.io.ptrs[1] @[Accel.scala 61:14]
    ce.io.ptrs[2] <= rf.io.ptrs[2] @[Accel.scala 61:14]
    
  module TestAccel : 
    input clock : Clock
    input reset : UInt<1>
    input sim_clock : Clock
    output sim_wait : UInt<1>
    
    inst sim_shell of VTASimShell @[TestAccel.scala 59:25]
    sim_shell.clock <= clock
    sim_shell.reset <= reset
    inst vta_accel of Accel @[TestAccel.scala 60:25]
    vta_accel.clock <= clock
    vta_accel.reset <= reset
    sim_shell.sim_clock <= sim_clock @[TestAccel.scala 61:23]
    sim_wait <= sim_shell.sim_wait @[TestAccel.scala 62:12]
    vta_accel.io.mem.rd.bits <= sim_shell.mem.rd.bits @[TestAccel.scala 63:17]
    vta_accel.io.mem.rd.valid <= sim_shell.mem.rd.valid @[TestAccel.scala 63:17]
    sim_shell.mem.rd.ready <= vta_accel.io.mem.rd.ready @[TestAccel.scala 63:17]
    sim_shell.mem.wr.bits <= vta_accel.io.mem.wr.bits @[TestAccel.scala 63:17]
    sim_shell.mem.wr.valid <= vta_accel.io.mem.wr.valid @[TestAccel.scala 63:17]
    sim_shell.mem.req.addr <= vta_accel.io.mem.req.addr @[TestAccel.scala 63:17]
    sim_shell.mem.req.len <= vta_accel.io.mem.req.len @[TestAccel.scala 63:17]
    sim_shell.mem.req.opcode <= vta_accel.io.mem.req.opcode @[TestAccel.scala 63:17]
    sim_shell.mem.req.valid <= vta_accel.io.mem.req.valid @[TestAccel.scala 63:17]
    sim_shell.host.resp.bits <= vta_accel.io.host.resp.bits @[TestAccel.scala 64:21]
    sim_shell.host.resp.valid <= vta_accel.io.host.resp.valid @[TestAccel.scala 64:21]
    sim_shell.host.req.deq <= vta_accel.io.host.req.deq @[TestAccel.scala 64:21]
    vta_accel.io.host.req.value <= sim_shell.host.req.value @[TestAccel.scala 64:21]
    vta_accel.io.host.req.addr <= sim_shell.host.req.addr @[TestAccel.scala 64:21]
    vta_accel.io.host.req.opcode <= sim_shell.host.req.opcode @[TestAccel.scala 64:21]
    vta_accel.io.host.req.valid <= sim_shell.host.req.valid @[TestAccel.scala 64:21]
    
